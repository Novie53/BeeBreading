local config = {
    ["analyzerDir"] = "west", --From the perspecive of the chest above the compuer
	["ditchDir"] = "south",	--From the perspecive of the chest above the compuer
	["refChest"] = "up", --From the perspecive of the chest above the compuer
	["refChestSize"] = 81,
	["IgnoreCondition"] = true, 
	["EnsureCount15"] = 5, --Must be atleast 1
	["DroneNumberDump"] = 100,
	["BreedEverythingInPath"] = true,
	["outputChest"] = "east"
}
local traitPriority = {
	["speed"] = 10,
	["lifespan"] = 0.08,
	["fertility"] = 0.4,
	["nocturnal"] = 0.1,
	["tolerantFlyer"] = 0.1,
	["caveDwelling"] = 0.1,
	["temperatureTolerance"] = 0.5,
	["humidityTolerance"] = 0.5,
	["effect"] = 0,
	["flowering"] = 0,
	["flowerProvider"] = 0,
	["territory"] = 0
}
local tArgs = {...}

local RefTable = {}
local beeList = {}
local inv = peripheral.wrap("top")
local api = peripheral.wrap("left")
local mutationTable
local catalog
inv.size = inv.getInventorySize()


function getRefDrone(specie, destiSlotDrone, droneCount)--Todo
	log("Grabbing a refrenseDrone, "..specie)
	while RefTable[specie]["drone"].beeData.qty == 1 do
		log("Need to breed more Drones")
		creatRefrenseDrones(specie)
	end
	inv.pullItem("up", RefTable[specie]["drone"].beeData.slot, droneCount, destiSlotDrone)
end
function creatRefrenseDrones(specie)
	log("Creating more Refrense Drones")
	
	
	
	getRefPair(specie, 1, 53, 54)
	FindAGoodName(53, 54)
	
	
	local droneSlot
	local prinSlot
	for i,v in pairs(inv.getAllStacks()) do
		if not isAnalyzed(v) then
			if isBeeOrPrincess(v) == 1 then--Prin
				prinSlot = i
			else--Drone
				droneSlot = i
			end
		end
	end
	anaLyzeBee(prinSlot, inv)
	anaLyzeBee(droneSlot, inv)
	
	RefTable[specie]["drone"].beeData.qty = RefTable[specie]["drone"].beeData.qty + inv.getStackInSlot(droneSlot).qty - 1
	
	returnRefPair(specie, prinSlot, droneSlot)
end

function log(text, bool)
	if not bool then
		print(tostring(text))
	end
end

function haveRecipe(targetSpecie)
	if mutationTable[targetSpecie] == nil then
		return false
	else
		return true
	end
end
function isBeeOrPrincess(bee)--1=Prin,2=Drone,3 Rest
	if bee.rawName == "item.beeprincessge" then
		return 1
	elseif bee.rawName == "item.beedronege" then
		return 2
	else
		return 3
	end
end
function isAnalyzed(bee)--True/False
	return bee.beeInfo.isAnalyzed
end
function HaveRefPair(specie)--True/False, ifall man har redan den species som refrense
	return beeList[specie]
end
function fixBeeName(name)
	return name:gsub("bees%.species%.",""):gsub("^.", string.upper)
end
function isPureBreed(bee)--True/False
	if bee.beeInfo.active.species == bee.beeInfo.inactive.species then
		return true
	else
		return false
	end
end
function alreadyHave(targetSpecie)--1:harRef, 2:harNågon, 3:false
	if HaveRefPair(targetSpecie) then
		return 1
	elseif catalog.princessesBySpecies[targetSpecie] ~= nil or 
		catalog.dronesBySpecies[targetSpecie] ~= nil then
		return 2
	else
		return 3
	end
end
function count(tab)
	local count = 0
	for i,v in pairs(tab) do count = count + 1 end
	return count
end
function fixBee(bee)
	if bee.beeInfo == nil then
		bee.active.species = fixBeeName(bee.active.species)
		bee.inactive.species = fixBeeName(bee.inactive.species)
	else
		bee.beeInfo.active.species = fixBeeName(bee.beeInfo.active.species)
		bee.beeInfo.inactive.species = fixBeeName(bee.beeInfo.inactive.species)
	end
end


function getRefPair(specie, droneCount, destiSlotPrin, destiSlotDrone)
	inv.pullItem(config.refChest, RefTable[specie]["prin"].beeData.slot, 1, destiSlotPrin)
	inv.pullItem(config.refChest, RefTable[specie]["drone"].beeData.slot, droneCount, destiSlotDrone)
end
function returnRefPair(specie, prinSlot, droneSlot)
	inv.pushItem(config.refChest, prinSlot, 64, RefTable[specie]["prin"].beeData.slot)
	inv.pushItem(config.refChest, droneSlot, 64, RefTable[specie]["drone"].beeData.slot)
end
function FindAGoodName(princessSlot, droneSlot)
	local function waitForTheApi()
		log("Waiting for the apiary")
		local x,y = term.getCursorPos()
		term.setCursorPos(24,y-1)
		
		local dotCount = 0
		while api.getStackInSlot(1) ~= nil do
			sleep(1.5)
			term.write(".")
			dotCount = dotCount + 1
			
			if dotCount > 5 then
				dotCount = 0
				term.clearLine()
				local x,y = term.getCursorPos()
				term.setCursorPos(1,y)
				term.write("Waiting for the apiary ")
			end
		end
		print("")
	end
	
	api.pullItem("up", princessSlot, 1, 1)
	api.pullItem("up", droneSlot, 1, 2)
	
	waitForTheApi()
	return clearApiary(api)
end
function anaLyzeBee(slot)
	log("Analyzing bee in slot: "..slot)
	inv.pushItem(config.analyzerDir, slot, 64, 3)
	local sec = 5
	sleep(5)
	while inv.pullItem(config.analyzerDir, 9, 64, slot) == 0 do
		sleep(1)
		sec = sec + 1
		if sec == 30 then
			log("-- You probably need to refill honey --")
		end
	end
end
function catalogBees()
	local function addBySpecies(beesBySpecies, bee)
		if beesBySpecies[bee.beeInfo.active.species] == nil then
			beesBySpecies[bee.beeInfo.active.species] = {bee}
		else
			table.insert(beesBySpecies[bee.beeInfo.active.species], bee)
		end
		if bee.beeInfo.inactive.species ~= bee.beeInfo.active.species then
			if beesBySpecies[bee.beeInfo.inactive.species] == nil then
				beesBySpecies[bee.beeInfo.inactive.species] = {bee}
			else
				table.insert(beesBySpecies[bee.beeInfo.inactive.species], bee)
			end
		end
	end
	
	catalog = {}
	catalog.princessesBySpecies = {}
	catalog.dronesBySpecies = {}
		
	for specie, beePair in pairs(RefTable) do	
		addBySpecies(catalog.dronesBySpecies, beePair["drone"].beeData)
	end
	
	for slot, bee in pairs(inv.getAllStacks()) do
		fixBee(bee)
		bee.slot = slot
		
		if isBeeOrPrincess(bee) == 1 then -- princess
			addBySpecies(catalog.princessesBySpecies, bee)
		else -- drones
			bee.ref = false
			addBySpecies(catalog.dronesBySpecies, bee)
		end
	end
end

--Todo Göra det mer modulärt genom att man hittar en fri slot och arbetar runt den istället för att alltid försöka att arbeta runt sista slott
--Todo kolla ifall FindAGoodName returnar alla slot som den har skicka en ny bee till så man inte behöver använda hacken och söka igenom inv för bee som inte är analyzerade



function findPureBreeds(specie)
	local purePrin = {}
	local pureDrone = {}
	for ignore,v in pairs(catalog.princessesBySpecies[specie]) do
		if isPureBreed(v) then
			table.insert(purePrin, v)
		end
	end
	for ignore,v in pairs(catalog.dronesBySpecies[specie]) do
		if isPureBreed(v) then
			table.insert(pureDrone, v)
		end
	end
	return purePrin, pureDrone
end
function findBestBee(beeTable)
	for slot, bee in pairs(beeTable) do
		scoreBee(bee)
	end
	
	local bestInSlot
	for slot, bee in pairs(beeTable) do
		if bestInSlot == nil then
			bestInSlot = slot
		else
			if beeTable[bestInSlot].beeInfo.score.total < bee.beeInfo.score.total then
				bestInSlot = slot
			end
		end
	end
	return bestInSlot
end
function mutateBeeChance(princess, drone, targetSpecies)
	local function mutateSpeciesChance(species1, species2)
		if species1 == species2 and species1 == targetSpecies then
			return 100
		elseif species1 == targetSpecies or species2 == targetSpecies then
			return 50
		end
		
		for ignore,v in pairs(mutationTable[targetSpecies]) do
			if (species1 == v.beeOne and species2 == v.beeTwo) or
			(species2 == v.beeOne and species1 == v.beeTwo) then
				return v.chance
			end
		end
		return 0
	end

	return (mutateSpeciesChance(princess.beeInfo.active.species, drone.beeInfo.active.species) / 4
             +mutateSpeciesChance(princess.beeInfo.inactive.species, drone.beeInfo.active.species) / 4
             +mutateSpeciesChance(princess.beeInfo.active.species, drone.beeInfo.inactive.species) / 4
             +mutateSpeciesChance(princess.beeInfo.inactive.species, drone.beeInfo.inactive.species) / 4)
end
function scoreBee(bee)
	local function scoreFromTable(tab, trait)
		if tab[bee.beeInfo.active[trait]] == nil then
			log("score Value for "..trait.." Could not be found, Value = "..bee.beeInfo.active[trait])
		end
		if tab[bee.beeInfo.inactive[trait]] == nil then
			log("score Value for "..trait.." Could not be found, Value = "..bee.beeInfo.inactive[trait])
		end
		
		return (tab[bee.beeInfo.active[trait]] + tab[bee.beeInfo.inactive[trait]]) / 2 * traitPriority[trait]
	end
	local function scoreFromBoolean(trait)
		local function convertToInt(boolean)
			if boolean then
				return 1
			else
				return 0
			end		
		end
		
		return (convertToInt(bee.beeInfo.active[trait]) + 
				convertToInt(bee.beeInfo.inactive[trait]))
				/ 2 * traitPriority[trait]
	end
	local function scoreFromInt(trait)
		return (bee.beeInfo.active[trait] + 
				bee.beeInfo.inactive[trait])
				/ 2 * traitPriority[trait]
	end
	local function fixTerritory()
		if type(bee.beeInfo.active.territory) == "table" then
			bee.beeInfo.active.territory = string.format("%s:%s:%s", 
			bee.beeInfo.active.territory[1],
			bee.beeInfo.active.territory[2],
			bee.beeInfo.active.territory[3])
		end
		if type(bee.beeInfo.inactive.territory) == "table" then
			bee.beeInfo.inactive.territory = string.format("%s:%s:%s", 
			bee.beeInfo.inactive.territory[1],
			bee.beeInfo.inactive.territory[2],
			bee.beeInfo.inactive.territory[3])
		end
	end
	
	local toleranceTable = {
		["None"] = 0,
		["Both 1"] = 2
	}
	local effectTable = {
		["None"] = 0
	}
	local flowerTable = {
		["Flowers"] = 5,
		["Rocks"] = 3,
	}
	local territoryTable = {
		["9:6:9"] = 0
	}
	
	bee.beeInfo.score = {}
	fixTerritory()
	
	bee.beeInfo.score.temperatureTolerance = scoreFromTable(toleranceTable, "temperatureTolerance")
	bee.beeInfo.score.humidityTolerance = scoreFromTable(toleranceTable, "humidityTolerance")
	bee.beeInfo.score.effect = scoreFromTable(effectTable, "effect")
	bee.beeInfo.score.flowerProvider = scoreFromTable(flowerTable, "flowerProvider")
	bee.beeInfo.score.territory = scoreFromTable(territoryTable, "territory")
	bee.beeInfo.score.tolerantFlyer = scoreFromBoolean("tolerantFlyer")
	bee.beeInfo.score.caveDwelling = scoreFromBoolean("caveDwelling")
	bee.beeInfo.score.nocturnal = scoreFromBoolean("nocturnal")
	bee.beeInfo.score.fertility = scoreFromInt("fertility")
	bee.beeInfo.score.flowering = scoreFromInt("flowering")
	bee.beeInfo.score.speed = scoreFromInt("speed")
	bee.beeInfo.score.lifespan = scoreFromInt("lifespan")
	
	
	local total = 0 
	for i,v in pairs(bee.beeInfo.score) do
		total = total + v
	end
	bee.beeInfo.score.total = total
end
function getBreedingTable()
	local function addToMuatationTable(mutTable, data, id)
		if mutTable[data.result] == nil then
			mutTable[data.result] = {}
		end
		local count = #mutTable[data.result]+1
		
		mutTable[data.result][count] = {}
		mutTable[data.result][count].beeOne = data.allele1
		mutTable[data.result][count].beeTwo = data.allele2
		mutTable[data.result][count].chance = data.chance
		mutTable[data.result][count].ID = id
		mutTable[data.result][count].result = data.result
		if #data["specialConditions"] > 0 then
			mutTable[data.result][count].hasSpecialCondition = true
			mutTable[data.result][count] = data.specialConditions
		else
			mutTable[data.result][count].hasSpecialCondition = false
		end
	end
	
	local mutationTable = {}
	log("Sorting Breeding Table")
	for id,v in pairs(api.getBeeBreedingData()) do
	
		v.allele1 = fixBeeName(v.allele1)
		v.allele2 = fixBeeName(v.allele2)
		v.result = fixBeeName(v.result)
		
		beeList[v.allele1] = false
		beeList[v.allele2] = false
		beeList[v.result] = false
		addToMuatationTable(mutationTable, v, id)
	end
	return mutationTable
end
function lookForNewRef()
	local speciesToCheck = {}
	log("Looking for new Refrense Pair")
	for specie, tab in pairs(catalog.princessesBySpecies) do
		for ignore, bee in pairs(tab) do
			if isPureBreed(bee) and catalog.dronesBySpecies[specie] ~= nil and not HaveRefPair(specie) then
				speciesToCheck[specie] = false
			end
		end
	end
	for specie, ignore in pairs(speciesToCheck) do
		for slot, bee in pairs(catalog.dronesBySpecies[specie]) do
			if isPureBreed(bee) then
				speciesToCheck[specie] = true
			end
		end
	end
	
	
	for specie, bool in pairs(speciesToCheck) do
		if bool then
			log("Potential new Ref Pair:"..specie)
			if ensurePureBreed(specie) then
				log("Succeded")
				sortBees()
				
				local purePrin, pureDrone = findPureBreeds(specie)
				purePrin = purePrin[findBestBee(purePrin)]
				pureDrone = pureDrone[findBestBee(pureDrone)]
				
				addToRef(purePrin, pureDrone)
			else
				log("Failed")
			end
		end
	end
end
function sortBees()
	local function ditchDrones()
		log("Ditching obsolete Drones")
		if config.DroneNumberDump > (inv.size - #inv.getAllStacks()) then
			for slot, bee in pairs(inv.getAllStacks()) do
				fixBee(bee)
				if isBeeOrPrincess(bee) == 2 and -- The bee is a drone
				HaveRefPair(bee.beeInfo.active.species) and -- Already have a refrense princess for the active species
				HaveRefPair(bee.beeInfo.inactive.species) then -- Already have a refrense princess for the inactive species
					while inv.pushItem(config.ditchDir,slot) == 0 do
						log("DitchChest is full")
						log("Fix it !!!!!!!!!!!!!!!!!")
						io.read()
					end
				end
			end
		end
	end
	local function analyzeAllBees()
		log("Analyzing Bees")
		inv.condenseItems()
		for i,v in pairs(inv.getAllStacks()) do
			if not isAnalyzed(v) then
				anaLyzeBee(i)
			end
		end
		inv.condenseItems()
	end
	
	log("Sorting Bees")
	analyzeAllBees()
	ditchDrones()
	catalogBees()
end
function clearApiary()--Returns beeCount that was extracted, 
	-- 1:Princess Slot
	-- 2:Drone Slot
	-- 3-9 Output Slots
	-- 10-12 Frame Slots
	log("Clearing Apiary")
	local beeCount = 0
	local inv = api.getAllStacks()
	for slot = 3, 9 do
		if inv[slot] then
			if isBeeOrPrincess(inv[slot]) ~= 3 then
				if api.pushItem("up",slot) == 0 then
					log("Error: MainChest is full")
					log("Press [ENTER] When ready")
					io.read()
				else
					beeCount = beeCount + 1
				end
			else
				if api.pushItem(config.outputChest, slot) == 0 then
					log("Error: OutputChest is full")
					log("Press [ENTER] When ready")
					io.read()
				end
			end
		end
	end
	return beeCount
end
function clearAnalyzer()
	log("Clearing Analyzer")
	for i=1,12 do
		inv.pullItem(config.analyzerDir, i)
	end
end
function addToRef(beePrin, beeDrone)
	local specie = beePrin.beeInfo.active.species
	local oldPrinSlot = beePrin.slot
	local oldDroneSlot = beeDrone.slot
	log("Adding "..specie.." to the refTable")
	
	beeList[specie] = true
	RefTable[specie] = {}
	RefTable[specie]["prin"] = {}
	RefTable[specie]["drone"] = {}
	
	RefTable[specie]["prin"].beeData = beePrin
	RefTable[specie]["prin"].beeData.slot = count(RefTable)*2-1
	
	RefTable[specie]["drone"].beeData = beeDrone
	RefTable[specie]["drone"].beeData.slot = count(RefTable)*2
	RefTable[specie]["drone"].beeData.ref = true
	
	inv.pushItem(config.refChest, oldPrinSlot, 64, RefTable[specie]["prin"].beeData.slot)
	inv.pushItem(config.refChest, oldDroneSlot, 64, RefTable[specie]["drone"].beeData.slot)
end
function cataLogRefChest()
	RefTable = {}
	log("Catalogging all refrenseBeePairs")
	
	if inv.getStackInSlot(27) ~= nil then
		inv.swapStacks(27, inv.size)
	end
	if inv.getStackInSlot(26) ~= nil then
		inv.swapStacks(26, inv.size-1)
	end
	
	for i=2, config.refChestSize, 2 do
		if inv.pullItem(config.refChest, i, 64, 27) == 0 then break end
		inv.pullItem(config.refChest, i-1, 64, 26)
		
		local prin = inv.getStackInSlot(26)
		local drone = inv.getStackInSlot(27)
		fixBee(prin)
		fixBee(drone)
		prin.slot = 26
		drone.slot = 27
		
		if not isPureBreed(prin) and isPureBreed(drone) then
			log("Error: Current RefPair in slot:"..prin.slot..","..drone.slot.." is not purebreed")
			io.read()
			return
		end
		addToRef(prin, drone)
	end
end


function reBreedQueen(specie)
	log("Need to breed a queen to match the recipe, "..specie)
	local prin
	for i,v in pairs(catalog.princessesBySpecies) do
		for a,d in pairs(v) do
			prin = d
			break
		end
	end
	
	while not isPureBreed(prin) and prin.beeInfo.active.species == specie do
		if inv.getStackInSlot(27) ~= nil then
			inv.swapStacks(27, inv.size)
		end
		getRefDrone(specie, 27, 1)
		FindAGoodName(prinSlot, 27)
		
		for i,v in pairs(inv.getAllStacks()) do
			if not isAnalyzed(v) then
				if isBeeOrPrincess(v) == 1 then --Prin
					prinSlot = i
				end
			end
		end
	end
end
function ensurePureBreed(specie)
	local pureCount = 0
	while pureCount < config.EnsureCount15 do
		log(specie..":"..pureCount)
		sortBees()
		if catalog.princessesBySpecies[specie] == nil or 
			catalog.dronesBySpecies[specie] == nil then
			return false
		end
		local purePrin, pureDrone = findPureBreeds(specie)

		if #purePrin == 0 or #pureDrone == 0 then
			return false
		end
		purePrin = purePrin[findBestBee(purePrin)]
		pureDrone = pureDrone[findBestBee(pureDrone)]

		if FindAGoodName(purePrin.slot, pureDrone.slot) == 2 then
			pureCount = pureCount + 1
		else
			pureCount = 0
		end
	end
	return true
end
function breedTarget(specificMutation)
	local function containsAtleastOneSpecie(searthTable)
		local newTable = {}
		for specie,table1 in pairs(searthTable) do
			if specie == specificMutation.beeOne or specie == specificMutation.beeTwo or specie == specificMutation.result then
				for ignore,v in pairs(table1) do
					local found = false
					for a,d in pairs(newTable) do
						if d.slot == v.slot then
							found = true
						end
					end
					if not found then
						table.insert(newTable,v)
					end
				end
			end
		end
		return newTable
	end
	local function crossMatch(tabPrin, tabDrone)
		local newTable = {}
		for ignore, beePrin in pairs(tabPrin) do
			for ignore, beeDrone in pairs(tabDrone) do
				local temp = {}
				temp.beePrin = beePrin
				temp.beeDrone = beeDrone
				table.insert(newTable, temp)
			end
		end
		return newTable
	end
	
	while not HaveRefPair(specificMutation.result) do
		log(specificMutation.beeOne.."+"..specificMutation.beeTwo.."="..specificMutation.result)

		local prinTa = containsAtleastOneSpecie(catalog.princessesBySpecies)
		
		if count(prinTa) == 0 then
			reBreedQueen(specificMutation.beeOne)
			prinTa = containsAtleastOneSpecie(catalog.princessesBySpecies)
		end
		
		local droneTa = containsAtleastOneSpecie(catalog.dronesBySpecies)
		local combinations = crossMatch(prinTa, droneTa)
		
		local highestTable = {}
		local highest = 0
		
		for ignore,table1 in pairs(combinations) do
			local tempVal = mutateBeeChance(table1.beePrin, table1.beeDrone, specificMutation.result)
			log(string.format("Prin:%s-%s, Drone:%s-%s, Chance:",string.sub(table1.beePrin.beeInfo.active.species,0,3),
																 string.sub(table1.beePrin.beeInfo.inactive.species,0,3),
																 string.sub(table1.beeDrone.beeInfo.active.species,0,3),
																 string.sub(table1.beeDrone.beeInfo.inactive.species,0,3))
																 ..tempVal, true)
			if tempVal > highest then
				highestTable = {}
				highest = tempVal
				table.insert(highestTable, table1)
			elseif tempVal == highest then
				table.insert(highestTable, table1)
			end
		end
		log("Highest chance to get "..specificMutation.result.." is "..highest.."%")	
		
		local picked = highestTable[1]
		if #highestTable > 1 then
			for ignore,table1 in pairs(highestTable) do
				scoreBee(table1.beePrin)
				scoreBee(table1.beeDrone)
				table1.score = (table1.beePrin.beeInfo.score.total + table1.beeDrone.beeInfo.score.total) / 2
			end
			
			local highestScore = 0
			for ignore, table1 in pairs(highestTable) do
				if table1.score > highestScore then
					highestScore = table1.score
					picked = table1
				end
			end
		end
		
		if picked.beeDrone.ref then
			if inv.getStackInSlot(27) ~= nil then
				inv.swapStacks(27, inv.size)
			end
			getRefDrone(picked.beeDrone.beeInfo.active.species, 27, 1)
			picked.beeDrone.slot = 27
		end
			
		FindAGoodName(picked.beePrin.slot, picked.beeDrone.slot)
		sortBees()
		lookForNewRef()
	end
	sortBees()
end
function getAllPossible(targetSpecies)
	local function oneLayer(target, tab)
		for ignore,v in pairs(mutationTable[target]) do
			if not (config.IgnoreCondition and v.hasSpecialCondition) then
				table.insert(tab, v)
			end
		end
	end
	
	local processed = {}
	local stack = {}
	local NewStack = {}
	
	oneLayer(targetSpecies, stack)
	while #stack > 0 do
		for i,v in pairs(stack) do
			v.beeOneHaveRecipe = haveRecipe(v.beeOne)
			v.beeTwoHaveRecipe = haveRecipe(v.beeTwo)
			v.beeOneAlreadyHave = alreadyHave(v.beeOne)
			v.beeTwoAlreadyHave = alreadyHave(v.beeTwo)
		end
		
		for i,v in pairs(stack) do
			
			if v.beeOneHaveRecipe then
				oneLayer(v.beeOne, NewStack)
			end
			if v.beeTwoHaveRecipe then
				oneLayer(v.beeTwo, NewStack)
			end
		end
		for k,v in pairs(stack) do table.insert(processed, v) end
		stack = NewStack
		NewStack = {}
	end
	
	local alreadyHave = false
	for i=1,#processed do
		for a=1, #NewStack do
			if processed[i].ID == NewStack[a].ID then
				alreadyHave = true
			end
		end
		if not alreadyHave then
			table.insert(NewStack, processed[i])
		end
	end
	processed = NewStack
	NewStack = {}
	
	
	for i=1,#processed do
		if (processed[i].beeOneAlreadyHave ~= 3 or processed[i].beeOneHaveRecipe) 
		and (processed[i].beeTwoAlreadyHave ~= 3 or processed[i].beeTwoHaveRecipe)
		and not HaveRefPair(processed[i].result) then
			table.insert(NewStack, processed[i])
		end
	end
	
	if #NewStack == 0 then
		log(" -- Need more starter Bees -- ")
		log(" -- Press ENTER when ready -- ")
		io.read()
	end
	
	return NewStack
end
function MainRec(targetSpecies)
	local stuffToBreed = getAllPossible(targetSpecies)
	
	if config.BreedEverythingInPath then
		while count(stuffToBreed) ~= 0 do
			for ignore, table1 in pairs(stuffToBreed) do
				while count(catalog.dronesBySpecies) == 0 do
					log(" -- Need more drones -- ")
					log(" -- Press ENTER when ready -- ")
					io.read()
					sortBees()
				end
				while count(catalog.princessesBySpecies) == 0 do
					log(" -- Need more princesses -- ")
					log(" -- Press ENTER when ready -- ")
					io.read()
					sortBees()
				end
				
				if HaveRefPair(table1.beeOne) and HaveRefPair(table1.beeTwo) then
					breedTarget(table1)
					table.remove(stuffToBreed, ignore)
				end
			end
		end
	else
		log("Todo")
		io.read()
	end
end


function main()
	mutationTable = getBreedingTable()
	cataLogRefChest()
	clearApiary()
	clearAnalyzer()
	sortBees()
	lookForNewRef()
	
	log("Prep is finished")	
	if tArgs[1] == nil then
		log("Enter a species to aim for")
		return
	end
	
	local targetSpecies = tArgs[1]:sub(1,1):upper()..tArgs[1]:sub(2):lower()

	if beeList[targetSpecies] == nil then
		log("Could not find a species with the name: "..targetSpecies)
		return
	elseif HaveRefPair(targetSpecies) then
		log(string.format("There already is a purebreed %s in the refrense chest", targetSpecies))
		return	
	else
		log("Main Target is "..targetSpecies)
	end
		
	MainRec(targetSpecies)
end


main()
